{"version":3,"sources":["index.js"],"names":["COLS","ROWS","EMPTY","SNAKE","FRUIT","UP","DOWN","LEFT","RIGHT","KEY_LEFT","KEY_UP","KEY_RIGHT","KEY_DOWN","canvas","ctx","keystate","frames","score","grid","width","height","_grid","init","defaultValue","columns","rows","x","push","y","set","val","get","snake","direction","last","_queue","insert","unshift","remove","pop","setFood","empty","randPosition","Math","floor","random","length","main","document","createElement","setAttribute","getContext","body","appendChild","font","addEventListener","event","keyCode","loop","startPosition","update","draw","window","requestAnimationFrame","newX","newY","tail","tileWidth","tileHeight","fillStyle","fillRect","fillText","renderCheck","getElementById","removeChild","innerWidth","hiderDiv","textContent","location","reload"],"mappings":"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","file":"c29b79decb49f58fd0d994814dfc6972.map","sourcesContent":["\n/**\n * Constants\n */\nvar \n    COLS=30, ROWS=35, /* */\n    EMPTY=0, SNAKE=1, FRUIT=2, // grid values (to determine if a grid x,y is empty, filled with the snake, or filled with fruit)\n    UP=0, DOWN=1, LEFT=2, RIGHT=3, /* Snake directions */\n    KEY_LEFT=37, KEY_UP=38, KEY_RIGHT=39, KEY_DOWN=40 /* Key codes */\n\n/**\n * Game Objects\n*/\nvar \n    canvas, \n    ctx, \n    keystate, \n    frames,\n    score=0\n\n/**\n * Grid Data Structure.  Creates a 2D grid represented by \n * an array of arrays. \n * \n * @type {Object}\n */\nvar grid = {\n    width: null, /* number, the number of columns */\n    height: null, /* number, the number of rows */\n    _grid: null, /* Array<any>, the data representation */\n\n    /**\n     * Initiate, filling a columns x rows grid with the defaultValue\n     * \n     * @param {any} defaultValue default value to fill with \n     * @param {number} columns number of columns\n     * @param {number} rows number of rows\n     */\n    init: function(defaultValue,columns,rows) {\n        this.width = columns\n        this.height = rows\n\n        this._grid = []\n        // create empty grid (2D array) with columns.length arrays,\n        // filled with rows.length defaultGridValues (0?)\n        for (let x = 0; x < columns; x++) {\n            this._grid.push([])\n            for (let y = 0; y < rows; y++) {\n                this._grid[x].push(defaultValue)\n            }\n        }\n    },\n\n    // set [val] at x,y position in _grid array\n    set: function(val, x, y) {\n        // set value of grid at position x,y (x column and y row)\n        this._grid[x][y] = val\n    },\n\n    // get value from _grid at x,y position\n    get: function(x, y) {\n        return this._grid[x][y]\n    }\n}\n\nvar snake = {\n    direction: null,\n    last: null,\n    _queue: null, // list of actions to execute for snake?\n\n    init: function(direction, x, y) {\n        this._queue = []\n        this.direction = direction\n\n        // set first starting position of snake\n        this.insert(x,y)\n    },\n\n    /**\n     * Add to the start of the snake's queue. Set the\n     * last snake location to the newest one.\n     * \n     * @param {number} x X coordinate for insert \n     * @param {number} y Y coordinate for insert \n     */\n    insert: function(x, y) {\n        // add to the start of the queue \n        this._queue.unshift({x:x, y:y})\n        // set the last queue position...? why? from the one we just entered?\n        this.last = this._queue[0]\n    },\n\n    remove: function() {\n        // remove last element of snake queue array\n        return this._queue.pop()\n    }\n}\n\nfunction setFood() {\n    // get all empty spots in the grid\n    var empty = []\n    for (let x = 0; x < grid.width; x++) {\n        for (let y =0; y < grid.height; y++) {\n            if (grid.get(x,y) === EMPTY) {\n                empty.push({x:x, y:y})\n            }\n        }\n    }\n    // get random empty space position from this empty list\n    var randPosition = empty[Math.floor(Math.random()*empty.length)]\n    grid.set(FRUIT, randPosition.x, randPosition.y)\n}\n\nfunction main() {\n    canvas = document.createElement('canvas')\n    canvas.setAttribute('id', 'snake-canvas')\n    canvas.width = COLS*20\n    canvas.height = ROWS*20\n    ctx = canvas.getContext('2d')\n    document.body.appendChild(canvas)\n    ctx.font = '12px Quicksand'\n\n    frames = 0\n    keystate = {}\n\n    document.addEventListener('keydown', function(event){\n        keystate[event.keyCode] = true\n    })\n    document.addEventListener('keyup', function(event){\n        delete keystate[event.keyCode]\n    })\n\n    init()\n    loop()\n\n}\n\nfunction init() {\n    grid.init(EMPTY, COLS, ROWS)\n    score = 0\n\n    // COLS/2 to get middle of the screen (but math.floor to ensure whole number)\n    // ROWS-1 to start at the bottom row going UP\n    var startPosition = {x: Math.floor(COLS/2), y: ROWS-1}\n    snake.init(UP, startPosition.x, startPosition.y)\n    grid.set(SNAKE, startPosition.x, startPosition.y)\n    setFood()\n}\n\nfunction loop() {\n    update()\n    draw()\n\n    // tell the browser that you want to perform an animation, and that\n    // you want to call loop() every time it \"re-paints\" the animation\n    window.requestAnimationFrame(loop, canvas)\n}\n\nfunction update() {\n    frames++\n\n    if (keystate[KEY_LEFT] && snake.direction !== RIGHT){\n        snake.direction = LEFT\n    }\n    if (keystate[KEY_RIGHT] && snake.direction !== LEFT){\n        snake.direction = RIGHT \n    }\n    if (keystate[KEY_UP] && snake.direction !== DOWN){\n        snake.direction = UP \n    }\n    if (keystate[KEY_DOWN] && snake.direction !== UP){\n        snake.direction = DOWN \n    }\n\n    // every 5 frames...\n    if (frames%5 === 0) {\n        // get previous snake state\n        var newX = snake.last.x\n        var newY = snake.last.y\n\n        /**\n         * based on the direction of snake movement,\n         * increment or decrement the previous snake state\n         */\n        switch (snake.direction) {\n            case LEFT:\n                newX--\n                break\n            case RIGHT:\n                newX++\n                break\n            case UP:\n                newY--\n                break\n            case DOWN:\n                newY++\n                break\n        }\n        /**\n         * if newly changed snake state is out of bounds or\n         * is a tile currently occupied by the snake, start \n         * the game over and return.\n         */\n        if (newX < 0 || newX > grid.width-1 || \n            newY < 0 || newY > grid.height-1 ||\n            grid.get(newX, newY) === SNAKE \n        ) {\n            return init()\n        }\n\n        /**\n         * otherwise, if it's a fruit,\n         */\n        var tail\n        if (grid.get(newX, newY) === FRUIT) {\n            score++\n            tail = {x:newX, y:newY}\n            setFood()\n        } else {\n            /**\n             * Remove the last element in snake queue, and\n             * set those coordinates to be empty. Then set  \n             * tail to our new coordinates (instead of the ones\n             * returned by snake.remove) to use for setting the\n             * new tile below.\n             */\n            tail = snake.remove()\n            grid.set(EMPTY, tail.x, tail.y)\n            tail.x = newX\n            tail.y = newY\n        }\n\n        grid.set(SNAKE, tail.x, tail.y)\n        snake.insert(tail.x, tail.y)\n    }\n\n}\n\nfunction draw() {\n    // draw the tiles in the grid\n    var tileWidth = canvas.width / grid.width // get's specfic canvas tile width based on the size of our grid\n    var tileHeight = canvas.height / grid.height // get's specfic canvas tile height based on the size of our grid\n\n    // loop through grid to find out which type of tile each tile (x,y) is,\n    // then set the context fill color depending on the type.\n    for (let x = 0; x < grid.width; x++) {\n        for (let y = 0; y < grid.height; y++) {\n            switch(grid.get(x,y)) {\n                case EMPTY:\n                    ctx.fillStyle = '#f4f4f4'\n                    break\n                case SNAKE:\n                    ctx.fillStyle = '#5C7762'\n                    break\n                case FRUIT:\n                    ctx.fillStyle = '#C64C41'\n                    break\n            }\n            // draw a rectangle starting at position (x*tileWidth, y*tileHeight) - this gets the exact\n            // canvas position we want to start at, based on our grid location - with a rectangle width \n            // and height of (tileWidth, tileHeight)\n            ctx.fillRect(x*tileWidth, y*tileHeight, tileWidth, tileHeight)\n        }\n    }\n    ctx.fillStyle = '#000'\n    ctx.fillText(`SCORE: ${score}`, 10, canvas.height - 10)\n}\nfunction renderCheck() {\n    if (document.getElementById('mobile-hider')) {\n        document.body.removeChild(document.getElementById('mobile-hider'))\n    }\n    if (document.getElementById('snake-canvas')) {\n        document.body.removeChild(document.getElementById('snake-canvas'))\n    }\n    var width = window.innerWidth\n    if (width < 1000) {\n        var hiderDiv = document.createElement('div')\n        hiderDiv.setAttribute('id', 'mobile-hider')\n        hiderDiv.textContent = 'Sorry!  The snake game is only available on devices with a larger screen size than this one.'\n        document.body.appendChild(hiderDiv)\n    } else {\n        location.reload()\n    }\n}\n// renderCheck()\nwindow.addEventListener('resize', renderCheck)\nmain()"]}